# .github/workflows/preview-publish.yml
name: Preview Package Publishing

on:
  pull_request:
    branches: [feat/v3]
    types: [opened, synchronize, reopened]

jobs:
  check-changes:
    runs-on: ubuntu-latest
    outputs:
      packages-changed: ${{ steps.changes.outputs.packages }}
      other-files-changed: ${{ steps.changes.outputs.other }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: dorny/paths-filter@v2
        id: changes
        with:
          filters: |
            packages:
              - 'packages/**'
            other:
              - 'apps/**'
              - 'src/**'
              - 'docs/**'
              - 'components/**'
              - 'public/**'
              - '*.md'
              - '*.json'
              - '*.js'
              - '*.ts'
              - '*.tsx'
              - '*.css'
              - '*.scss'
              - '*.html'
              - '*.yml'
              - '*.yaml'
              - 'scripts/**'
              - 'templates/**'
              - '!packages/**'

  publish-preview:
    needs: check-changes
    if: needs.check-changes.outputs.packages-changed == 'true'
    runs-on: ubuntu-latest
    outputs:
      published: ${{ steps.publish.outputs.published }}
      version: ${{ steps.version.outputs.version }}
      packages: ${{ steps.publish.outputs.packages }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'yarn'

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Generate preview version
        id: version
        run: |
          PR_NUMBER=${{ github.event.pull_request.number }}
          SHORT_SHA=$(git rev-parse --short HEAD)
          PREVIEW_VERSION="0.0.0-pr-${PR_NUMBER}-${SHORT_SHA}"
          echo "version=${PREVIEW_VERSION}" >> $GITHUB_OUTPUT
          echo "üè∑Ô∏è  Generated preview version: ${PREVIEW_VERSION}"

      - name: Update package versions
        run: |
          # Update only root-level package.json files in packages/ directory (not node_modules)
          for package_dir in packages/*/; do
            if [ ! -f "${package_dir}package.json" ]; then
              continue
            fi
            
            # Skip if it's a node_modules directory
            if [[ "$package_dir" == *"/node_modules/"* ]]; then
              continue
            fi
            
            package_file="${package_dir}package.json"
            
            # Create backup
            cp "$package_file" "$package_file.bak"
            
            # Update version using Node.js
            node -e "
              const fs = require('fs');
              const pkg = JSON.parse(fs.readFileSync('$package_file', 'utf8'));
              pkg.version = '${{ steps.version.outputs.version }}';
              fs.writeFileSync('$package_file', JSON.stringify(pkg, null, 2) + '\n');
            "
            
            echo "‚úÖ Updated version in $package_file to ${{ steps.version.outputs.version }}"
          done

      - name: Update internal package references
        run: |
          echo "üîÑ Updating internal package references to preview versions..."

          # Update all package.json files to reference the preview versions of internal packages
          for package_dir in packages/*/; do
            if [ ! -f "${package_dir}package.json" ]; then
              continue
            fi
            
            package_file="${package_dir}package.json"
            
            # Update dependencies that reference other packages in this monorepo
            node -e "
              const fs = require('fs');
              const path = require('path');
              const pkg = JSON.parse(fs.readFileSync('$package_file', 'utf8'));
              const previewVersion = '${{ steps.version.outputs.version }}';
              let changed = false;
              
              // Update dependencies
              ['dependencies', 'devDependencies', 'peerDependencies'].forEach(depType => {
                if (pkg[depType]) {
                  Object.keys(pkg[depType]).forEach(dep => {
                    // If this dependency starts with @gluestack-ui-nightly, update it to preview version
                    if (dep.startsWith('@gluestack-ui-nightly/')) {
                      console.log(\`Updating \${dep} from \${pkg[depType][dep]} to \${previewVersion} in \${depType}\`);
                      pkg[depType][dep] = previewVersion;
                      changed = true;
                    }
                  });
                }
              });
              
              if (changed) {
                fs.writeFileSync('$package_file', JSON.stringify(pkg, null, 2) + '\n');
                console.log('‚úÖ Updated dependencies in $package_file');
              } else {
                console.log('‚ÑπÔ∏è  No internal dependencies found in $package_file');
              }
            "
          done

      - name: Setup NPM authentication
        run: |
          echo "//registry.npmjs.org/:_authToken=${{ secrets.NPM_TOKEN }}" > ~/.npmrc

      - name: Publish packages in correct order
        id: publish
        run: |
          # Create a temporary file to track published packages
          PUBLISHED_PACKAGES_FILE=$(mktemp)
          SUCCESS=false

          echo "üöÄ STARTING EXPLICIT PACKAGE PUBLISHING ORDER"
          echo "===================================================="

          # Function to publish a single package
          publish_package() {
            local package_dir="$1"
            local step_name="$2"
            
            echo ""
            echo "[$step_name] Attempting to publish: $package_dir"
            
            if [ ! -f "${package_dir}/package.json" ]; then
              echo "[$step_name] ‚ùå No package.json found in $package_dir"
              return 1
            fi
            
            # Get package info
            local PACKAGE_JSON=$(cat "${package_dir}/package.json")
            local PACKAGE_NAME=$(echo "$PACKAGE_JSON" | node -e "
              try {
                const pkg = JSON.parse(require('fs').readFileSync('/dev/stdin', 'utf8'));
                console.log(pkg.name || '');
              } catch(e) { console.log(''); }
            ")
            local IS_PRIVATE=$(echo "$PACKAGE_JSON" | node -e "
              try {
                const pkg = JSON.parse(require('fs').readFileSync('/dev/stdin', 'utf8'));
                console.log(pkg.private === true ? 'true' : 'false');
              } catch(e) { console.log('false'); }
            ")
            
            if [ -z "$PACKAGE_NAME" ]; then
              echo "[$step_name] ‚è≠Ô∏è  Skipping: No package name found"
              return 1
            fi
            
            if [ "$IS_PRIVATE" = "true" ]; then
              echo "[$step_name] ‚è≠Ô∏è  Skipping: Private package ($PACKAGE_NAME)"
              return 1
            fi
            
            echo "[$step_name] üì¶ Publishing: $PACKAGE_NAME"
            
            cd "$package_dir"
            
            # Clear npm cache to avoid workspace resolution issues
            echo "[$step_name] üóëÔ∏è  Clearing npm cache..."
            npm cache clean --force || echo "Cache clean failed, continuing..."
            
            # Remove existing node_modules and package-lock.json to ensure fresh install
            echo "[$step_name] üßπ Cleaning existing dependencies..."
            rm -rf node_modules package-lock.json yarn.lock || echo "Cleanup had issues, continuing..."
            
            # Install dependencies first to get latest preview packages
            echo "[$step_name] üì• Installing dependencies (fresh install)..."
            npm install --no-package-lock --registry https://registry.npmjs.org/ || echo "‚ö†Ô∏è  Install had issues, but continuing..."
            
            # Force install the specific preview version of utils if this is core package
            if [[ "$PACKAGE_NAME" == *"core"* ]]; then
              echo "[$step_name] üéØ Force installing preview utils package..."
              npm install @gluestack-ui-nightly/utils@${{ steps.version.outputs.version }} --no-save --registry https://registry.npmjs.org/ || echo "‚ö†Ô∏è  Utils install had issues, but continuing..."
              
              # Verify utils package is available in node_modules
              if [ -d "node_modules/@gluestack-ui-nightly/utils" ]; then
                echo "[$step_name] ‚úÖ Utils package found in node_modules"
                UTILS_VERSION=$(node -e "try { console.log(require('./node_modules/@gluestack-ui-nightly/utils/package.json').version) } catch(e) { console.log('unknown') }")
                echo "[$step_name] üì¶ Installed utils version: $UTILS_VERSION"
              else
                echo "[$step_name] ‚ùå Utils package NOT found in node_modules"
              fi
            fi
            
            # Build the package
            if npm run --list 2>/dev/null | grep -q "\bbuild\b"; then
              echo "[$step_name] üî® Building $PACKAGE_NAME..."
              if ! npm run build; then
                echo "[$step_name] ‚ùå Build failed for $PACKAGE_NAME"
                cd - > /dev/null
                return 1
              fi
            fi
            
            # Publish with preview tag
            echo "[$step_name] üöÄ Publishing to npm..."
            if npm publish --tag preview --access public; then
              echo "[$step_name] ‚úÖ SUCCESS: Published $PACKAGE_NAME@${{ steps.version.outputs.version }}"
              echo "$PACKAGE_NAME@${{ steps.version.outputs.version }}" >> "$PUBLISHED_PACKAGES_FILE"
              
              # Longer delay to ensure npm registry has the package
              echo "[$step_name] ‚è≥ Waiting 15 seconds for npm propagation..."
              sleep 15
              
              # Verify the package is available on npm registry
              echo "[$step_name] üîç Verifying package availability on npm..."
              for i in {1..6}; do
                if npm view "$PACKAGE_NAME@${{ steps.version.outputs.version }}" version >/dev/null 2>&1; then
                  echo "[$step_name] ‚úÖ Package confirmed available on npm registry"
                  break
                else
                  echo "[$step_name] ‚è≥ Package not yet available, waiting 10 more seconds... (attempt $i/6)"
                  sleep 10
                fi
              done
              
              cd - > /dev/null
              return 0
            else
              echo "[$step_name] ‚ùå FAILED to publish $PACKAGE_NAME"
              cd - > /dev/null
              return 1
            fi
          }

          # STEP 1: Publish utils package FIRST
          echo ""
          echo "üîß STEP 1: PUBLISHING UTILS PACKAGE"
          echo "===================================="
          UTILS_PUBLISHED=false

          # Try common utils directory names
          for utils_dir in "packages/gluestack-utils" "packages/utils" "packages/gluestack-ui-utils"; do
            if [ -d "$utils_dir" ]; then
              echo "Found utils directory: $utils_dir"
              if publish_package "$utils_dir" "UTILS"; then
                SUCCESS=true
                UTILS_PUBLISHED=true
                break
              fi
            fi
          done

          # If not found by directory, search by package name
          if [ "$UTILS_PUBLISHED" = false ]; then
            echo "Searching for utils package by name..."
            for dir in packages/*/; do
              if [ -f "${dir}package.json" ]; then
                pkg_name=$(node -e "try { console.log(JSON.parse(require('fs').readFileSync('${dir}package.json')).name || '') } catch(e) { console.log('') }")
                if [[ "$pkg_name" == *"@gluestack-ui-nightly/utils"* ]]; then
                  echo "Found utils package by name: $dir ‚Üí $pkg_name"
                  if publish_package "$dir" "UTILS"; then
                    SUCCESS=true
                    UTILS_PUBLISHED=true
                    break
                  fi
                fi
              fi
            done
          fi

          if [ "$UTILS_PUBLISHED" = false ]; then
            echo "‚ùå CRITICAL: Utils package not found or failed to publish!"
          fi

          # STEP 2: Publish core package SECOND  
          echo ""
          echo "üèóÔ∏è  STEP 2: PUBLISHING CORE PACKAGE"
          echo "==================================="
          CORE_PUBLISHED=false

          # Try common core directory names
          for core_dir in "packages/gluestack-core" "packages/core" "packages/gluestack-ui-core"; do
            if [ -d "$core_dir" ]; then
              echo "Found core directory: $core_dir"
              if publish_package "$core_dir" "CORE"; then
                SUCCESS=true
                CORE_PUBLISHED=true
                break
              fi
            fi
          done

          # If not found by directory, search by package name
          if [ "$CORE_PUBLISHED" = false ]; then
            echo "Searching for core package by name..."
            for dir in packages/*/; do
              if [ -f "${dir}package.json" ]; then
                pkg_name=$(node -e "try { console.log(JSON.parse(require('fs').readFileSync('${dir}package.json')).name || '') } catch(e) { console.log('') }")
                if [[ "$pkg_name" == *"@gluestack-ui-nightly/core"* ]]; then
                  echo "Found core package by name: $dir ‚Üí $pkg_name"
                  if publish_package "$dir" "CORE"; then
                    SUCCESS=true
                    CORE_PUBLISHED=true
                    break
                  fi
                fi
              fi
            done
          fi

          # STEP 3: Publish all other packages LAST
          echo ""
          echo "üì¶ STEP 3: PUBLISHING OTHER PACKAGES"
          echo "===================================="

          for dir in packages/*/; do
            if [ -f "${dir}package.json" ]; then
              pkg_name=$(node -e "try { console.log(JSON.parse(require('fs').readFileSync('${dir}package.json')).name || '') } catch(e) { console.log('') }")
              
              # Skip if it's utils or core (already published)
              if [[ "$pkg_name" == *"utils"* ]] || [[ "$pkg_name" == *"core"* ]]; then
                echo "‚è≠Ô∏è  Skipping already processed: $pkg_name"
                continue
              fi
              
              echo "Found other package: $dir ‚Üí $pkg_name"
              if publish_package "$dir" "OTHER"; then
                SUCCESS=true
              fi
            fi
          done

          echo ""
          echo "üìä PUBLISHING SUMMARY"
          echo "===================="
          echo "Utils published: $UTILS_PUBLISHED"
          echo "Core published: $CORE_PUBLISHED"

          if [ "$SUCCESS" = true ]; then
            # Read all published packages into a single variable
            PUBLISHED_PACKAGES=$(cat "$PUBLISHED_PACKAGES_FILE" | tr '\n' ' ' | sed 's/ $//')
            echo "published=true" >> $GITHUB_OUTPUT
            echo "packages=$PUBLISHED_PACKAGES" >> $GITHUB_OUTPUT
            echo "‚úÖ FINAL RESULT: SUCCESS"
            echo "üìã Published packages: $PUBLISHED_PACKAGES"
          else
            echo "published=false" >> $GITHUB_OUTPUT
            echo "‚ùå FINAL RESULT: FAILED - No packages were published successfully"
          fi

          # Cleanup
          rm -f "$PUBLISHED_PACKAGES_FILE"

      - name: Restore package.json files
        if: always()
        run: |
          # Restore original package.json files
          for package_dir in packages/*/; do
            if [ ! -f "${package_dir}package.json.bak" ]; then
              continue
            fi
            
            backup_file="${package_dir}package.json.bak"
            original_file="${package_dir}package.json"
            
            mv "$backup_file" "$original_file"
            echo "‚úÖ Restored $original_file"
          done

      - name: Comment on PR
        if: steps.publish.outputs.published == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const packages = `${{ steps.publish.outputs.packages }}`.trim();

            if (!packages) {
              console.log('No packages published, skipping comment');
              return;
            }

            const comment = `## üöÄ Preview packages published!

            **Version:** \`${{ steps.version.outputs.version }}\`

            **Published packages:**
            ${packages.split(' ').map(pkg => `- \`${pkg}\``).join('\n')}

            > üí° These are preview packages for testing only.`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });

  trigger-vercel-preview-with-packages:
    needs: [check-changes, publish-preview]
    if: needs.check-changes.outputs.packages-changed == 'true' && needs.publish-preview.outputs.published == 'true'
    runs-on: ubuntu-latest
    outputs:
      deployed_projects: ${{ steps.deploy.outputs.deployed_projects }}
      deployment_urls: ${{ steps.deploy.outputs.deployment_urls }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Debug outputs
        run: |
          echo "üîç Debugging job outputs:"
          echo "Published: ${{ needs.publish-preview.outputs.published }}"
          echo "Version: ${{ needs.publish-preview.outputs.version }}"
          echo "Packages: ${{ needs.publish-preview.outputs.packages }}"
          echo "Packages changed: ${{ needs.check-changes.outputs.packages-changed }}"
          echo "Other files changed: ${{ needs.check-changes.outputs.other-files-changed }}"

      - name: Generate version for deployment
        id: version
        run: |
          # Use the published package version
          PACKAGE_VERSION="${{ needs.publish-preview.outputs.version }}"
          echo "üì¶ Using published package version: $PACKAGE_VERSION"
          echo "version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT

      - name: Trigger Vercel Preview Deployments
        id: deploy
        run: |
          # Parse project IDs from secrets
          PROJECT_IDS='${{ secrets.VERCEL_PROJECT_IDS }}'
          DEPLOYED_PROJECTS=""
          DEPLOYMENT_URLS=""
          PACKAGE_VERSION="${{ steps.version.outputs.version }}"

          echo "üì¶ Using version: $PACKAGE_VERSION"

          if [ -z "$PACKAGE_VERSION" ]; then
            echo "‚ùå Version is empty, cannot proceed with deployment"
            exit 1
          fi

          # Use process substitution to avoid subshell issues
          while IFS=':' read -r PROJECT_NAME PROJECT_ID; do
            echo "üöÄ Deploying $PROJECT_NAME (ID: $PROJECT_ID)..."
            
            # Create deployment using Vercel API with Git source for code changes
            RESPONSE=$(curl -s -X POST "https://api.vercel.com/v13/deployments" \
              -H "Authorization: Bearer ${{ secrets.VERCEL_TOKEN }}" \
              -H "Content-Type: application/json" \
              -d "{
                \"name\": \"$PROJECT_NAME-pr-${{ github.event.pull_request.number }}-${{ github.sha }}\",
                \"project\": \"$PROJECT_ID\",
                \"gitSource\": {
                  \"type\": \"github\",
                  \"ref\": \"${{ github.sha }}\",
                  \"sha\": \"${{ github.sha }}\",
                  \"repoId\": ${{ github.event.repository.id }}
                },
                \"meta\": {
                  \"githubCommitSha\": \"${{ github.sha }}\",
                  \"githubCommitAuthorName\": \"${{ github.actor }}\",
                  \"githubCommitMessage\": \"${{ github.event.pull_request.title }}\",
                  \"githubPR\": \"${{ github.event.pull_request.number }}\",
                  \"triggeredBy\": \"github-actions\",
                  \"packageVersion\": \"$PACKAGE_VERSION\"
                }
              }")
            
            # Extract deployment URL and ID
            DEPLOYMENT_URL=$(echo "$RESPONSE" | jq -r '.url // empty')
            DEPLOYMENT_ID=$(echo "$RESPONSE" | jq -r '.id // empty')
            ERROR_MESSAGE=$(echo "$RESPONSE" | jq -r '.error.message // empty')
            
            if [ -n "$DEPLOYMENT_URL" ] && [ -n "$DEPLOYMENT_ID" ]; then
              echo "‚úÖ Successfully triggered deployment for $PROJECT_NAME"
              echo "üìç Preview URL: https://$DEPLOYMENT_URL"
              DEPLOYED_PROJECTS="$DEPLOYED_PROJECTS $PROJECT_NAME"
              DEPLOYMENT_URLS="$DEPLOYMENT_URLS\\n- **$PROJECT_NAME**: https://$DEPLOYMENT_URL"
            else
              echo "‚ùå Failed to deploy $PROJECT_NAME"
              if [ -n "$ERROR_MESSAGE" ]; then
                echo "Error: $ERROR_MESSAGE"
              fi
              echo "Response: $RESPONSE"
            fi
          done < <(echo "$PROJECT_IDS" | jq -r 'to_entries[] | "\(.key):\(.value)"')

          # Save results for next step
          echo "deployed_projects=$DEPLOYED_PROJECTS" >> $GITHUB_OUTPUT
          echo "deployment_urls<<EOF" >> $GITHUB_OUTPUT
          echo "$DEPLOYMENT_URLS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Update PR with Vercel deployment info
        uses: actions/github-script@v7
        with:
          script: |
            const deploymentUrls = `${{ steps.deploy.outputs.deployment_urls }}`.trim();
            const deployedProjects = `${{ steps.deploy.outputs.deployed_projects }}`.trim();
            const packageVersion = `${{ steps.version.outputs.version }}`;

            if (!deployedProjects) {
              const errorComment = `## ‚ö†Ô∏è Vercel deployment failed
              
              No projects were deployed successfully. Please check the [workflow logs](${context.payload.repository.html_url}/actions/runs/${context.runId}) for details.
              `;
              
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: errorComment
              });
              return;
            }

            const successComment = `## üöÄ Vercel preview deployments triggered successfully!

            **Version:** \`${packageVersion}\`
            **Triggered by:** Package changes and publishing

            **Projects triggered for preview:**${deploymentUrls}

            ‚è±Ô∏è Deployments are building. Check your [Vercel dashboard](https://vercel.com/dashboard) for detailed status.

            > üí° These are preview deployments for testing only.
            `;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: successComment
            });

  trigger-vercel-preview-other-files:
    needs: check-changes
    if: needs.check-changes.outputs.other-files-changed == 'true' && needs.check-changes.outputs.packages-changed == 'false'
    runs-on: ubuntu-latest
    outputs:
      deployed_projects: ${{ steps.deploy.outputs.deployed_projects }}
      deployment_urls: ${{ steps.deploy.outputs.deployment_urls }}
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Debug outputs
        run: |
          echo "üîç Debugging job outputs:"
          echo "Packages changed: ${{ needs.check-changes.outputs.packages-changed }}"
          echo "Other files changed: ${{ needs.check-changes.outputs.other-files-changed }}"

      - name: Generate version for deployment
        id: version
        run: |
          # Generate a version for deployment tracking when no packages were published
          PR_NUMBER=${{ github.event.pull_request.number }}
          SHORT_SHA=$(git rev-parse --short HEAD)
          PACKAGE_VERSION="deploy-${PR_NUMBER}-${SHORT_SHA}"
          echo "üöÄ Generated deployment version: $PACKAGE_VERSION"
          echo "version=$PACKAGE_VERSION" >> $GITHUB_OUTPUT

      - name: Trigger Vercel Preview Deployments
        id: deploy
        run: |
          # Parse project IDs from secrets
          PROJECT_IDS='${{ secrets.VERCEL_PROJECT_IDS }}'
          DEPLOYED_PROJECTS=""
          DEPLOYMENT_URLS=""
          PACKAGE_VERSION="${{ steps.version.outputs.version }}"

          echo "üì¶ Using version: $PACKAGE_VERSION"

          if [ -z "$PACKAGE_VERSION" ]; then
            echo "‚ùå Version is empty, cannot proceed with deployment"
            exit 1
          fi

          # Use process substitution to avoid subshell issues
          while IFS=':' read -r PROJECT_NAME PROJECT_ID; do
            echo "üöÄ Deploying $PROJECT_NAME (ID: $PROJECT_ID)..."
            
            # Create deployment using Vercel API with Git source for code changes
            RESPONSE=$(curl -s -X POST "https://api.vercel.com/v13/deployments" \
              -H "Authorization: Bearer ${{ secrets.VERCEL_TOKEN }}" \
              -H "Content-Type: application/json" \
              -d "{
                \"name\": \"$PROJECT_NAME-pr-${{ github.event.pull_request.number }}-${{ github.sha }}\",
                \"project\": \"$PROJECT_ID\",
                \"gitSource\": {
                  \"type\": \"github\",
                  \"ref\": \"${{ github.sha }}\",
                  \"sha\": \"${{ github.sha }}\",
                  \"repoId\": ${{ github.event.repository.id }}
                },
                \"meta\": {
                  \"githubCommitSha\": \"${{ github.sha }}\",
                  \"githubCommitAuthorName\": \"${{ github.actor }}\",
                  \"githubCommitMessage\": \"${{ github.event.pull_request.title }}\",
                  \"githubPR\": \"${{ github.event.pull_request.number }}\",
                  \"triggeredBy\": \"github-actions\",
                  \"packageVersion\": \"$PACKAGE_VERSION\"
                }
              }")
            
            # Extract deployment URL and ID
            DEPLOYMENT_URL=$(echo "$RESPONSE" | jq -r '.url // empty')
            DEPLOYMENT_ID=$(echo "$RESPONSE" | jq -r '.id // empty')
            ERROR_MESSAGE=$(echo "$RESPONSE" | jq -r '.error.message // empty')
            
            if [ -n "$DEPLOYMENT_URL" ] && [ -n "$DEPLOYMENT_ID" ]; then
              echo "‚úÖ Successfully triggered deployment for $PROJECT_NAME"
              echo "üìç Preview URL: https://$DEPLOYMENT_URL"
              DEPLOYED_PROJECTS="$DEPLOYED_PROJECTS $PROJECT_NAME"
              DEPLOYMENT_URLS="$DEPLOYMENT_URLS\\n- **$PROJECT_NAME**: https://$DEPLOYMENT_URL"
            else
              echo "‚ùå Failed to deploy $PROJECT_NAME"
              if [ -n "$ERROR_MESSAGE" ]; then
                echo "Error: $ERROR_MESSAGE"
              fi
              echo "Response: $RESPONSE"
            fi
          done < <(echo "$PROJECT_IDS" | jq -r 'to_entries[] | "\(.key):\(.value)"')

          # Save results for next step
          echo "deployed_projects=$DEPLOYED_PROJECTS" >> $GITHUB_OUTPUT
          echo "deployment_urls<<EOF" >> $GITHUB_OUTPUT
          echo "$DEPLOYMENT_URLS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Update PR with Vercel deployment info
        uses: actions/github-script@v7
        with:
          script: |
            const deploymentUrls = `${{ steps.deploy.outputs.deployment_urls }}`.trim();
            const deployedProjects = `${{ steps.deploy.outputs.deployed_projects }}`.trim();
            const packageVersion = `${{ steps.version.outputs.version }}`;

            if (!deployedProjects) {
              const errorComment = `## ‚ö†Ô∏è Vercel deployment failed
              
              No projects were deployed successfully. Please check the [workflow logs](${context.payload.repository.html_url}/actions/runs/${context.runId}) for details.
              `;
              
              github.rest.issues.createComment({
                issue_number: context.issue.number,
                owner: context.repo.owner,
                repo: context.repo.repo,
                body: errorComment
              });
              return;
            }

            const successComment = `## üöÄ Vercel preview deployments triggered successfully!

            **Version:** \`${packageVersion}\`
            **Triggered by:** Other file changes (no packages published)

            **Projects triggered for preview:**${deploymentUrls}

            ‚è±Ô∏è Deployments are building. Check your [Vercel dashboard](https://vercel.com/dashboard) for detailed status.

            > üí° These are preview deployments for testing only.
            `;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: successComment
            });
