name: Production Package Publishing

on:
  push:
    branches: [feat/v3]
    paths:
      - 'packages/**'

jobs:
  check-changes:
    runs-on: ubuntu-latest
    outputs:
      packages-changed: ${{ steps.changes.outputs.packages }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: dorny/paths-filter@v2
        id: changes
        with:
          filters: |
            packages:
              - 'packages/**'

  publish-production:
    needs: check-changes
    if: needs.check-changes.outputs.packages-changed == 'true'
    runs-on: ubuntu-latest
    outputs:
      published: ${{ steps.publish.outputs.published }}
      version: ${{ steps.publish.outputs.version }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'yarn'

      - name: Install dependencies
        run: yarn install --frozen-lockfile

      - name: Setup NPM authentication
        run: |
          echo "//registry.npmjs.org/:_authToken=${{ secrets.NPM_TOKEN }}" > ~/.npmrc

      - name: Version packages with changesets
        id: version
        run: |
          # Check if there are changesets to consume
          if [ -d ".changeset" ] && [ "$(ls -A .changeset/*.md 2>/dev/null | wc -l)" -gt 0 ]; then
            echo "📝 Consuming changesets..."
            yarn changeset:version
            
            # Check if any package.json was modified
            if git diff --quiet; then
              echo "No version changes needed"
              echo "version_changed=false" >> $GITHUB_OUTPUT
            else
              echo "Version changes detected"
              echo "version_changed=true" >> $GITHUB_OUTPUT
              
              # Get the new version from the first package (assuming monorepo versioning)
              NEW_VERSION=$(node -e "
                const fs = require('fs');
                const packages = fs.readdirSync('packages');
                for (const pkg of packages) {
                  try {
                    const pkgJson = JSON.parse(fs.readFileSync(\`packages/\${pkg}/package.json\`, 'utf8'));
                    if (!pkgJson.private) {
                      console.log(pkgJson.version);
                      break;
                    }
                  } catch (e) {}
                }
              ")
              echo "version=${NEW_VERSION}" >> $GITHUB_OUTPUT
              
              # Commit version changes
              git config --local user.email "action@github.com"
              git config --local user.name "GitHub Action"
              git add .
              git commit -m "Version packages [skip ci]"
              git push
            fi
          else
            echo "No changesets found, skipping versioning"
            echo "version_changed=false" >> $GITHUB_OUTPUT
          fi

      - name: Publish packages
        id: publish
        if: steps.version.outputs.version_changed == 'true'
        run: |
          echo "🚀 Publishing packages..."
          PUBLISHED_PACKAGES=""

          find packages -name "package.json" -type f | while read file; do
            PACKAGE_DIR=$(dirname "$file")
            PACKAGE_JSON=$(cat "$file")
            PACKAGE_NAME=$(echo "$PACKAGE_JSON" | node -e "console.log(JSON.parse(require('fs').readFileSync('/dev/stdin', 'utf8')).name)")
            IS_PRIVATE=$(echo "$PACKAGE_JSON" | node -e "console.log(JSON.parse(require('fs').readFileSync('/dev/stdin', 'utf8')).private || false)")
            
            if [ "$IS_PRIVATE" = "true" ]; then
              echo "⏭️  Skipping private package: $PACKAGE_NAME"
              continue
            fi
            
            echo "📦 Publishing $PACKAGE_NAME from $PACKAGE_DIR..."
            
            cd "$PACKAGE_DIR"
            
            # Build if build script exists
            if yarn run --list 2>/dev/null | grep -q "build"; then
              echo "🔨 Building $PACKAGE_NAME..."
              yarn build
            fi
            
            # Publish to latest tag
            npm publish --access public
            
            if [ $? -eq 0 ]; then
              PACKAGE_VERSION=$(node -e "console.log(JSON.parse(require('fs').readFileSync('package.json', 'utf8')).version)")
              echo "✅ Successfully published $PACKAGE_NAME@$PACKAGE_VERSION"
              PUBLISHED_PACKAGES="$PUBLISHED_PACKAGES $PACKAGE_NAME@$PACKAGE_VERSION"
            else
              echo "❌ Failed to publish $PACKAGE_NAME"
              exit 1
            fi
            
            cd - > /dev/null
          done

          echo "published=true" >> $GITHUB_OUTPUT
          echo "packages=$PUBLISHED_PACKAGES" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        if: steps.publish.outputs.published == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const { execSync } = require('child_process');

            // Get latest tag
            let latestTag;
            try {
              latestTag = execSync('git describe --tags --abbrev=0', { encoding: 'utf8' }).trim();
            } catch (e) {
              latestTag = '';
            }

            // Generate changelog
            let changelog = '## Changes\n\n';
            if (latestTag) {
              try {
                const commits = execSync(`git log ${latestTag}..HEAD --oneline --no-merges`, { encoding: 'utf8' })
                  .trim()
                  .split('\n')
                  .filter(line => line.length > 0)
                  .map(line => `- ${line}`)
                  .join('\n');
                changelog += commits || 'No significant changes';
              } catch (e) {
                changelog += 'Unable to generate changelog';
              }
            } else {
              changelog += 'Initial release';
            }

            // Create release
            const tagName = `v${{ steps.version.outputs.version }}`;
            await github.rest.repos.createRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              tag_name: tagName,
              name: tagName,
              body: changelog + '\n\n**Published packages:**\n${{ steps.publish.outputs.packages }}',
              draft: false,
              prerelease: false
            });

  trigger-vercel-production:
    needs: [check-changes, publish-production]
    if: needs.publish-production.outputs.published == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Trigger Vercel Production Deployment
        run: |
          curl -X POST "https://api.vercel.com/v1/integrations/deploy/${{ secrets.VERCEL_DEPLOY_HOOK_PRODUCTION }}" \
            -H "Authorization: Bearer ${{ secrets.VERCEL_TOKEN }}" \
            -H "Content-Type: application/json" \
            -d '{
              "name": "production-release",
              "source": "github-action",
              "target": "production",
              "meta": {
                "githubCommitSha": "${{ github.sha }}",
                "githubCommitAuthorName": "${{ github.actor }}",
                "packageVersion": "${{ needs.publish-production.outputs.version }}"
              }
            }'
